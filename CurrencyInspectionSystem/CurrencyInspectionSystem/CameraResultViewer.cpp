// CameraResultViewer.cpp : implementation file
//
#include "stdafx.h"
#include "CameraResultViewer.h"
#include "afxdialogex.h"
#include <math.h>
#include <vector>
#include <sstream>
#include "InspectionParametersConfigReader.h"

using namespace std;

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

char* overInkingDefectcolors[3] = { "medium goldenrod", "gold","goldenrod" };
char* underInkingDefectcolors[3] = { "light blue", "medium aquamarine", "medium sea green" };

//
static const int DataRateTimer = 1;
static const int ChartUpdateTimer = 2;
static const int DataInterval = 20;
static const int StripChartUpdateTimer = 3;
// CameraResultViewer dialog

IMPLEMENT_DYNAMIC(CameraResultViewer, CDialogEx)

CameraResultViewer::CameraResultViewer(CWnd* pParent /*=NULL*/)
	: CDialogEx(IDD_DIALOG_CAMERA_RESULT_VIEWER, pParent)
	, m_imagenumber(_T(""))
	, m_shiftInfo(_T(""))
{
	m_pEditBkBrush = new CBrush(DialogBackgroundColor);
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	InitializeCriticalSection(&imageMutex);
	InitializeCriticalSection(&resultMutex);
	resultReceived = false;
	chartData = make_shared<ChartDataManager>();
	inspectionWindow.GenEmptyRegion();
	layerResult = NULL;
	baResult = NULL;
	thResult = NULL;
	isShift = false;
	selectedStripIndex = 0;
	startdocCount = 0;
}

CameraResultViewer::~CameraResultViewer()
{
	m_pEditBkBrush->DeleteObject();
	DeleteCriticalSection(&imageMutex);
	DeleteCriticalSection(&resultMutex);
	delete m_ResultHistoryViewer.getChart();
}

void CameraResultViewer::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_STATS_WINDOW_GROUP, contGroupBoxStatsWindow);
	DDX_Control(pDX, IDC_STATIC_HALCON_RESULT_WINDOW, staticImageWindow);
	DDX_Control(pDX, IDC_STRIPCHART_RESULT, m_ResultHistoryViewer);
	DDX_Control(pDX, IDC_STATIC_BOX_RESULTCHART, contGroupBoxStripChart);
	DDX_Text(pDX, IDC_STATIC_IMAGENUMBER, m_imagenumber);
	DDX_Text(pDX, IDC_STATIC_CURRENT_SHIFT_INFO, m_shiftInfo);
}



BEGIN_MESSAGE_MAP(CameraResultViewer, CDialog)
	//{{AFX_MSG_MAP(CameraResultViewer)
	ON_WM_PAINT()
	ON_WM_TIMER()
	ON_WM_DESTROY()
	//ON_WM_ERASEBKGND()
	ON_WM_CTLCOLOR()
	//}}AFX_MSG_MAP
	ON_CONTROL(CVN_MouseMoveChart, IDC_STRIPCHART_RESULT, OnMouseMovePlotArea)
	ON_CONTROL(BN_CLICKED, IDC_STRIPCHART_RESULT, OnClickStrip)
	ON_MESSAGE(UWM_CAMERA_RESULT_RECEIVED, &CameraResultViewer::OnCameraResultReceivedMessage)
	ON_BN_CLICKED(IDC_BUTTON1, &CameraResultViewer::OnBnClickedButton1)
//	ON_CONTROL(CVN_ViewPortChanged, IDC_STRIPCHART_RESULT, OnViewPortChanged)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CameraResultViewer message handlers

//
// Initialization
//
BOOL CameraResultViewer::OnInitDialog()
{
	CDialog::OnInitDialog();

	// *** code automatically generated by VC++ MFC AppWizard ***
	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);         // Set big icon
	SetIcon(m_hIcon, FALSE);        // Set small icon
	CRect rect;
	CPaintDC dc(this);
	// Creates a 12-point-Courier-font
	//CreateFontObject(1, &m_Font);
	m_Font.CreatePointFont(150, L"Arial");
	GetDlgItem(IDC_STATIC_TREETEXT)->SetFont(&m_Font);
	contGroupBoxStripChart.GetWindowRect(&stripRect);
	ScreenToClient(stripRect);
	staticImageWindow.GetClientRect(&rect);
	imageWindow.OpenWindow(0, 0, rect.Width(), rect.Height(), (int)staticImageWindow.m_hWnd, "visible", "");
	isHWindowInitialized = true;
	//imageWindow.RegisterForHalconWindowEvents(this);
	CRect rect1;
	contGroupBoxStatsWindow.GetWindowRect(&rect1);
	ScreenToClient(rect1);
	CPoint topLeftPos = rect1.TopLeft();
	resultstatswindow.Create(ResultStatsWindow::IDD, this);								// Initialize member variables
	resultstatswindow.SetWindowPos(&wndTop, (int)topLeftPos.x, (int)topLeftPos.y,rect1.Width(), rect1.Height(), SWP_SHOWWINDOW);
	resultstatswindow.UpdateWindow();
	resultstatswindow.ShowWindow(SW_RESTORE);
	/*HImage dem = HImage("E:\\Images\\500Sheet_Scaled.bmp");
	imageWindow.AddImage(dem);	*/
	ScreenToClient(stripRect);
	m_UpdatePeriod = 250;
	SetTimer(ChartUpdateTimer, m_UpdatePeriod, 0);
	selectedStripboxLeft = selectedStripboxRight = 0;
	
	GetDlgItem(IDC_STATIC_IMAGENUMBER)->SetFont(&m_Font);
	GetDlgItem(IDC_STATIC_CURRENT_SHIFT_INFO)->SetFont(&m_Font);
	return TRUE;
}

// *** code automatically generated by VC++ MFC AppWizard ***
// If you add a minimize button to your dialog, you will need the code below
// to draw the icon.  For MFC applications using the document/view model,
// this is automatically done for you by the framework.
void CameraResultViewer::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM)dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

BOOL CameraResultViewer::OnEraseBkgnd(CDC * pDC)
{
	CRect rect;
	GetClientRect(&rect);
	CBrush myBrush(DialogBackgroundColor);    // dialog background color
	CBrush *pOld = pDC->SelectObject(&myBrush);
	BOOL bRes = pDC->PatBlt(0, 0, rect.Width(), rect.Height(), PATCOPY);
	pDC->SelectObject(pOld);    // restore old brush
	return bRes;                       // CDialog::OnEraseBkgnd(pDC);
	


}

//
// View port changed event
//
void CameraResultViewer::OnViewPortChanged()
{
//	drawChart(&m_ResultHistoryViewer);
}

HBRUSH CameraResultViewer::OnCtlColor(CDC* pDC, CWnd *pWnd, UINT nCtlColor)
{	
	switch(nCtlColor) {

          case CTLCOLOR_MSGBOX:
			  pDC->SetTextColor(DialogStaticTextColor);
			  pDC->SetBkColor(DialogBackgroundColor);
			  return (HBRUSH)(m_pEditBkBrush->GetSafeHandle());
		  case CTLCOLOR_EDIT:
			  // Set color to green on black and return the background
			  pDC->SetTextColor(DialogStaticTextColor);
			  pDC->SetBkColor(DialogBackgroundColor);
			  return (HBRUSH)(m_pEditBkBrush->GetSafeHandle());
		  case CTLCOLOR_LISTBOX:
			  // Set color to green on black and return the background
			  pDC->SetTextColor(DialogStaticTextColor);
			  pDC->SetBkColor(DialogBackgroundColor);
			  return (HBRUSH)(m_pEditBkBrush->GetSafeHandle());
		  case CTLCOLOR_BTN:
			  // Set color to green on black and return the background
			  pDC->SetTextColor(DialogStaticTextColor);
			  pDC->SetBkColor(DialogBackgroundColor);
			  return (HBRUSH)(m_pEditBkBrush->GetSafeHandle());
		  case CTLCOLOR_DLG:
			  // Set color to green on black and return the background
			  pDC->SetTextColor(DialogStaticTextColor);
			  pDC->SetBkColor(DialogBackgroundColor);
			  return (HBRUSH)(m_pEditBkBrush->GetSafeHandle());
		  case CTLCOLOR_SCROLLBAR:
			  // Set color to green on black and return the background
			  pDC->SetTextColor(DialogStaticTextColor);
			  pDC->SetBkColor(DialogBackgroundColor);
			  return (HBRUSH)(m_pEditBkBrush->GetSafeHandle());
		  case CTLCOLOR_STATIC:
			  // Set color to green on black and return the background
			  pDC->SetTextColor(DialogStaticTextColor);
			  pDC->SetBkColor(DialogBackgroundColor);
			  return (HBRUSH)(m_pEditBkBrush->GetSafeHandle());
		  case CTLCOLOR_MAX:
			  // Set color to green on black and return the background
			  pDC->SetTextColor(DialogStaticTextColor);
			  pDC->SetBkColor(DialogBackgroundColor);
			  return (HBRUSH)(m_pEditBkBrush->GetSafeHandle());

		  default:
			  return CDialog::OnCtlColor(pDC, pWnd, nCtlColor);
	}
}

void CameraResultViewer::OnTimer(UINT_PTR nIDEvent)
{
	try
	{
		switch (nIDEvent)
		{
		case ChartUpdateTimer:
			drawChart(&m_ResultHistoryViewer);
			//bool scaleHasChanged = m_ResultHistoryViewer.updateFullRangeH("x", chartData->imageNumber-50, chartData->imageNumber, Chart::KeepVisibleRange);
			////if(scaleHasChanged)
			//m_ResultHistoryViewer.updateViewPort(true, false);
			//m_ResultHistoryViewer.updateDisplay();
			char sTime[32], cTime[32];
			time_t currTime = 0;
			if (isShift)
			{
				//stimeinfo = localtime(&chartData->shiftStartedTime);
				//const char* stime = asctime(stimeinfo);
				strftime(sTime, 100, "%d/%m/%Y %T", std::localtime(&chartData->shiftStartedTime[0]));
				time(&currTime);
				CString elapsedTime = GetElapsedTime(chartData->shiftStartedTime.back(), currTime);
				strftime(cTime, 100, "%d/%m/%Y %T", std::localtime(&currTime));
				UpdateData();
				m_shiftInfo.Format(L"%s\t\t\t\t\t Created: %s\t\t\t\t%s ", CString(chartData->shiftName.c_str()), CString(sTime), elapsedTime);
			//	m_imagenumber.Format(L"Sheet No: %d\t\t\t Golden Name: %s", chartData->docCount, CString(chartData->goldenName.c_str()));
				UpdateData(FALSE);

			}
			
			break;
		}
	}
	catch (CException &ex)
	{
		MessageBoxW(_T("Camera Result Viewer CException"));
	}
	catch (HException &ex)
	{
		CString x;
		x.Format(_T("Camera Result Viewer Halcon exception: %S"), ex.ErrorMessage().Text());
		MessageBoxW(x);
	}

	CDialog::OnTimer(nIDEvent);
}

CString CameraResultViewer::GetElapsedTime(time_t &startTime, time_t &currTime)
{

	ULONG diff = (currTime- startTime)+ chartData->elapsedTime;
	CString str;
	str.Format(L"%02d:%02d:%02d", (int)(diff/3600)%24,(int)(diff /60)%60,(int)diff % 60);
	return str;
}

static void shiftData(double *data, int len, double newValue)
{
	memmove(data, data + 1, sizeof(*data) * (len - 1));
	data[len - 1] = newValue;
}

void CameraResultViewer::OnMouseMovePlotArea()
{
	trackBoxLegend((XYChart *)m_ResultHistoryViewer.getChart(), m_ResultHistoryViewer.getPlotAreaMouseX(),
		m_ResultHistoryViewer.getPlotAreaMouseY(),true);
	m_ResultHistoryViewer.updateDisplay();

	// Hide the track cursor when the mouse leaves the plot area
//	m_ResultHistoryViewer.removeDynamicLayer(CVN_MouseLeavePlotArea);

}

void CameraResultViewer::OnClickStrip()
{
	if(chartData->resultReceived)
		selectStripTask((XYChart *)m_ResultHistoryViewer.getChart(), m_ResultHistoryViewer.getPlotAreaMouseX(), m_ResultHistoryViewer.getPlotAreaMouseY());
	m_ResultHistoryViewer.updateDisplay();
}


void CameraResultViewer::selectStripTask(XYChart *c, int mouseX, int mouseY)
{
	double yValue = c->getYValue(mouseY);

	double s = (stripscale) / 2;
	if (yValue >= (chartData->stripYValues[0]) - 0.5 && yValue<chartData->stripYValues[chartData->stripYValues.size() - 1])
	{
		auto const value = lower_bound(chartData->stripYValues.begin(), chartData->stripYValues.end(), yValue);
		
			selectedStripboxLeft = c->getYCoor(*value + s);
			selectedStripboxRight = c->getYCoor(*value - s);

			selectedStripIndex=  value - chartData->stripYValues.begin();
			lastDisplayTaskID= chartData->stripCharttaskID[selectedStripIndex];
		
	}


}

void CameraResultViewer::trackBoxLegend(XYChart *c, int mouseX, int mouseY,bool isMouseOnPlotArea)
{
	if (chartData->resultReceived)
	{
		// Clear the current dynamic layer and get the DrawArea object to draw on it.
		DrawArea *d = c->initDynamicLayer();
		// The plot area object
		PlotArea *plotArea = c->getPlotArea();
		double yValue = c->getYValue(mouseY);
		double s = (stripscale) / 2;
	/*	for (int i = 0; i < chartData->taskLabelIDs.size(); i++)
		{
			double temp = (i + 1)*stripscale;
			int top = c->getXCoor(chartData->docCount - docSize);
			int bottom = c->getXCoor(chartData->docCount);
			int left=  c->getYCoor(temp+s);
			int right= c->getYCoor(temp-s);

			d->rect(top,left,bottom,right, 0xFFFFFF, Chart::Transparent);
		}*/

		if(yValue>=(chartData->stripYValues[0])-0.5 && yValue<chartData->stripYValues[chartData->stripYValues.size()-1])
		{
		auto const value = lower_bound(chartData->stripYValues.begin(), chartData->stripYValues.end(), yValue);

		int boxLeft = c->getYCoor(*value + s);
		int boxRight = c->getYCoor(*value - s);
		// Draw the hovered track box
		d->rect(0, boxLeft, stripRect.Width(), boxRight, 0xF5A403, Chart::Transparent);
		}
		

		// Draw the selected track box
		d->rect(0, selectedStripboxLeft,  stripRect.Width(),selectedStripboxRight, 0xF5A403, 0xCAF5A403);
	}


}


void CameraResultViewer::drawChart(CChartViewer * viewer)
{
	//Chart::setLicenseCode("DEVP-0000-13ca-b405-3b66UDEV-236W-3DSG-K4G6-23D6-D199");
	XYChart *stripchart = new XYChart(stripRect.Width(), stripRect.Height() - 5, chartbackgroundColor, chartedgeColor, 1);
	//if(chartData->modelReceived)
	realtimeStripChart(stripchart);

	trackBoxLegend(stripchart,/* viewer->isMouseOnPlotArea() ? */viewer->getPlotAreaMouseX() /*: stripchart->getPlotArea()->getRightX()*/,
		/*viewer->isMouseOnPlotArea() ?*/ viewer->getPlotAreaMouseY() /*: stripchart->getPlotArea()->getBottomY()*/, viewer->isMouseOnPlotArea());
		

	if ((chartData->docCount- startdocCount) < 5)
	{
		int i = chartData->taskLabelIDs.size() - 1;
		
		for (auto &e : chartData->taskLabelIDs)
		{
			double temp = (i + 1)*stripscale;
			chartData->stripYValues[i] = temp;
			chartData->stripLabelCoordX[i] = stripchart->getXCoor(chartData->docCount)+10;
			chartData->stripPercentCoordX[i] = stripchart->getXCoor(chartData->docCount - docSize)-1;
			chartData->stripLabelCoordY[i] = stripchart->getYCoor(temp) - 12;
			i--;
		}
	}
	viewer->syncLinearAxisWithViewPort("x", stripchart->xAxis());
	viewer->syncLinearAxisWithViewPort("y", stripchart->yAxis());


	delete viewer->getChart();
	viewer->setChart(stripchart);
	
}


//Draw Real time stripchart
void CameraResultViewer::realtimeStripChart(XYChart *c)
{

	c->yAxis()->setLinearScale(0, chartData->taskLabelIDs.size() +4);
	c->xAxis()->setTitle("No. of sheets", "arialbd.ttf", 8);
	c->xAxis()->setLinearScale(chartData->docCount - docSize, chartData->docCount, 10, 1);
	c->setClipping();
	//c->yAxis()->setLinearScale(0, 10);
	// In this example, we only use position 1, 3, 5 for the data series. Positions 0, 2, 4, 6 are
	// empty and serve as gaps.
	c->addTitle("Sheet Result History", "arialbd.ttf", 15, 0xff8401)->setBackground(titlebackgroundColor,
		-1, Chart::softLighting(Chart::Center));
	c->getDrawArea()->setAntiAlias(false, 1);

	c->setPlotArea(50, 60, stripRect.Width() - 230, stripRect.Height() - 104, -1, -1, Chart::Transparent)->setGridColor(Chart::Transparent,
		gridColor, Chart::Transparent, c->dashLineColor(gridColor, Chart::DotLine));
	c->xAxis()->setLabelStyle("arialbd.ttf", 8, 0xFFFFFF);
	c->yAxis()->setLabelFormat("");
	c->xAxis()->setColors(Chart::Transparent, labelColor, titleColor);
	c->yAxis()->setColors(Chart::Transparent, labelColor);
	//c->setClipping();
	c->yAxis()->setLabelStyle("arialbd.ttf", 3);
	int i = 0;
	for (auto &e : chartData->taskLabelIDs)
	{

		ScatterLayer *scatter0 = c->addScatterLayer(
			DoubleArray(chartData->imagecountData, docSize),
			ArrayMath(DoubleArray(chartData->stripChartData[0][e.first], docSize)).mul((i + 1)*stripscale),
			"", Chart::SquareSymbol, 12, 0x888888, Chart::Transparent);
		ScatterLayer *scatter1 = c->addScatterLayer(
			DoubleArray(chartData->imagecountData, docSize),
			ArrayMath(DoubleArray(chartData->stripChartData[1][e.first], docSize)).mul((i + 1)*stripscale),
			"", Chart::SquareSymbol, 12, 0xff0000, Chart::Transparent);
		ScatterLayer *scatter2 = c->addScatterLayer(
			DoubleArray(chartData->imagecountData, docSize),
			ArrayMath(DoubleArray(chartData->stripChartData[2][e.first], docSize)).mul((i + 1)*stripscale),
			"", Chart::SquareSymbol, 12, 0x00cc00, Chart::Transparent);

		scatter0->setSymbolScale(DoubleArray(&chartData->symbolwidth[0], chartData->symbolwidth.size()), Chart::XAxisScale,
			DoubleArray(&chartData->symbolheight[0], chartData->symbolheight.size()), Chart::YAxisScale);
		scatter1->setSymbolScale(DoubleArray(&chartData->symbolwidth[0], chartData->symbolwidth.size()), Chart::XAxisScale,
			DoubleArray(&chartData->symbolheight[0], chartData->symbolheight.size()), Chart::YAxisScale);
		scatter2->setSymbolScale(DoubleArray(&chartData->symbolwidth[0], chartData->symbolwidth.size()), Chart::XAxisScale,
			DoubleArray(&chartData->symbolheight[0], chartData->symbolheight.size()), Chart::YAxisScale);

		ostringstream displayText;
		
		
		
		if (chartData->resultReceived)
		{
			TextBox *text = c->addText(chartData->stripLabelCoordX[i], chartData->stripLabelCoordY[i], (chartData->stripChartLabel[i].c_str()), "arialbd.ttf", 15, 0xFFFFFF);
			TextBox *percenttext = c->addText(chartData->stripPercentCoordX[i], chartData->stripLabelCoordY[i], "%", "arial.ttf", 12, 0xFFFFFF);
			if (e.first != chartData->thisCameraModelData.taskID)
			{
				if (chartData->camResultData->taskResults[e.first]->result != 2)
					text->setFontColor(0xFF0000);
				else
					text->setFontColor(0xFFFFFF);
				//text->setMaxWidth(90);
				
			}
			else
			{
				if (camResultData->result != 2)
					text->setFontColor(0xFF0000);
				else
					text->setFontColor(0xFFFFFF);
			}
			double unfit = chartData->taskwiseResultCount[0][i] + chartData->taskwiseResultCount[1][i];
			double unfitP = unfit * 100 / (unfit + chartData->taskwiseResultCount[2][i]);
			displayText << c->formatValue(unfitP, "{value|0}") << "%";
			text->setAlignment(11);
			percenttext->setAlignment(9);
			percenttext->setFontStyle("arialbd.ttf");
			percenttext->setFontColor(percentageTextColor);
			//text->setBackground()
			percenttext->setText(displayText.str().c_str());
		}
		
		i++;
	}



}

void CameraResultViewer::OnCameraResultReceived(ULONG _imageNumber, weak_ptr<CameraResultData>_camResultData)
{
	if (!_camResultData.expired())
	{
		camResultData = _camResultData.lock();
		chartData->camResultData = camResultData;
	}
	chartData->imageNumber = _imageNumber;
	chartData->docCount = _imageNumber;
	try
	{
		if (chartData->modelReceived)
		{
			chartData->setTaskwiseResultData();
		}
	}
	catch (CException &ex)
	{
		MessageBoxW(_T("Result Display Collection Error: CException"));
	}
	catch (HException &ex)
	{
		CString x;
		x.Format(_T("Result Display Collection Error: %S"), ex.ErrorMessage().Text());
		MessageBoxW(x);
	}
	this->PostMessageW(UWM_CAMERA_RESULT_RECEIVED, (WPARAM)_imageNumber, (LPARAM)_imageNumber);
	//imageWindow.Clear();
	
}
void CameraResultViewer::SetCameraModelData(string cameraDataLocation)
{
	thisCameraModelData.ReadConfiguration(cameraDataLocation, false);
	inspectionWindow = thisCameraModelData.InspectionWindow;//
	resultstatswindow.SetCameraModelData(thisCameraModelData);
	chartData->setModelData(thisCameraModelData);
	lastDisplayTaskID = thisCameraModelData.taskID;
	chartData->temptaskLblIDs = chartData->taskLabelIDs;
	chartData->taskLabelIDs[chartData->thisCameraModelData.taskID] = chartData->thisCameraModelData.taskName.c_str();
	if (!chartData->isResume)
	{
		
		chartData->docCount = 0;
		
	}
	startdocCount = chartData->docCount;
	chartData->setTaskwiseModelData();
	chartData->modelReceived = true;
	chartData->initializeStripChartData();
	chartData->initializeTaskResultsCount();
	chartData->initializeStatsCountData();

	//SetInspectionResultTree();
	UpWisePartition = chartData->baData->UpWisePartation;
	upArray = upArray.TupleGenConst(UpWisePartition.CountObj(), 1);

	chartData->isResume = false;
}

void CameraResultViewer::setShiftData(ShiftData &_shiftData)
{
	chartData->shiftName = _shiftData.shiftName;
	chartData->shiftStartedTime = _shiftData.shiftStartedTime;
	chartData->shiftEndedTime = _shiftData.shiftEndedTime;
	chartData->goldenName = _shiftData.goldenName;
	chartData->shiftStartingHour = _shiftData.shiftStartingHour;
	chartData->totalShiftHours = _shiftData.totalShiftHours;
	chartData->shiftDate = _shiftData.shiftDate;
	chartData->userID = _shiftData.userID;
	chartData->perHourTarget = _shiftData.perHourTarget;
	chartData->elapsedTime = _shiftData.elapsedTime;
};
void CameraResultViewer::SetShiftData(ShiftData &shiftData)
{
	isShift = true;
	chartData=shiftData.camchartData[camID];
	setShiftData(shiftData);
	resultstatswindow.chartData = chartData;

}

void CameraResultViewer::EndShift(ShiftData &shiftData)
{
	
	while (resultReceived) {}
	Sleep(4000);
	isShift = false;
	chartData->resultReceived = false;
	chartData->modelReceived = false;
	shiftData.lastImagenumber = chartData->imageNumber;
	chartData = make_shared<ChartDataManager>();
	resultstatswindow.chartData = make_shared<ChartDataManager>();
}


void CameraResultViewer::DisplayResultRegion()
{
	//imageWindow.ClearRegion();
	failedUpRegions.GenEmptyRegion();
	EnterCriticalSection(&resultMutex);
	if (lastDisplayTaskID == thisCameraModelData.taskID)
	{
		for (auto &e : camResultData->taskResults)
		{
			if( (e.second->result == InspectionResults::Fail) && false==(e.second->typeOfInspection==inspection_type_LayerInspection || e.second->typeOfInspection == inspection_type_SpecialLayerInspection))
			{
				DisplayGraphicalResults(e.first,true);
			}

		}

	}
	else
	{
		DisplayGraphicalResults(lastDisplayTaskID,false);
	}
	LeaveCriticalSection(&resultMutex);
}


BOOL CameraResultViewer::PreTranslateMessage(MSG* pMsg)
{
	
	CRect rect;
	GetDlgItem(IDC_STATIC_HALCON_RESULT_WINDOW)->GetWindowRect(rect);
	POINT pt = pMsg->pt;
	
	BOOL bRet;
	if (pMsg->message == WM_KEYDOWN && (pMsg->wParam == VK_ESCAPE || pMsg->wParam == VK_RETURN))
	{
		bRet = TRUE; // do not dispatch message
	}
	else if (rect.PtInRect(pt))
	{
		imageWindow.eventhandler(pMsg);
		bRet = TRUE; // do not dispatch message
		SetFocus();
		bRet = CDialogEx::PreTranslateMessage(pMsg);
	}
	else
	{
		bRet = CDialogEx::PreTranslateMessage(pMsg);
	}
	return bRet;
}


void CameraResultViewer::DisplayGraphicalResults(int taskID, bool isCollaged)
{
	switch (camResultData->taskResults[taskID]->typeOfInspection)
	{
	case inspection_type_LayerInspection:
	case inspection_type_SpecialLayerInspection:
		layerResult = (LayerResultData *)camResultData->taskResults[taskID];
		//for (int i = 1; i <= layerResult->OveralldefectCandidatesMin.CountObj(); i++)
		//{
		imageWindow.AddNonMovableRegion(layerResult->OveralldefectCandidatesMin/*.SelectObj(i)*/, 3, "coral"/*overInkingDefectcolors[i-1]*/, "margin");
		imageWindow.AddNonMovableRegion(layerResult->OveralldefectCandidatesMax/*.SelectObj(i)*/, 3, "cyan" /*underInkingDefectcolors[i - 1]*/, "margin");
		//}
		break;
	case inspection_type_BlobAnalyser:
		baResult = (BlobAnalyzerResultData *)camResultData->taskResults[taskID];
		imageWindow.AddNonMovableRegion(baResult->dominantBlob, 3, "red", "margin");
		if (!isCollaged)
		imageWindow.AddNonMovableRegion(baResult->disconnectedMajorBlob, 3, "blue", "margin");
		upWiseStatus = baResult->groupOfDefectBlobsUPWiseStatus[taskID];
		failedUpIndex = -2;
		failedUpIndex = upWiseStatus.TupleAnd(upArray).TupleFind(1).TupleAdd(1);
		if (failedUpIndex[0] != 0)
			failedUpRegions = UpWisePartition.SelectObj(failedUpIndex);
		imageWindow.AddNonMovableRegion(failedUpRegions, 1, "red", "margin");
		break;
	case inspection_type_ThreadDetection:
		thResult = (ThreadResultData *)camResultData->taskResults[taskID];
		imageWindow.AddNonMovableRegion(thResult->threadRegion, 3, "yellow", "margin");
		break;
	case inspection_type_Measurement:
		break;
	}
}


LRESULT CameraResultViewer::OnCameraResultReceivedMessage(WPARAM wParam, LPARAM lParam)
{
	resultReceived = true;
	

	//resultstatswindow.PostMessageW(UWM_CAMERA_RESULT_RECEIVED, (WPARAM)chartData->imageNumber, reinterpret_cast<LPARAM>(chartData.get()));
	
	EnterCriticalSection(&resultMutex);
	
	ULONG imageNumber = wParam;

	HSystem::SetSystem("flush_graphic", "false");
	HTuple count;
	//Update Halcon Window with Result Image
	count = camResultData->imageData.image.CountChannels();
	if (count > 0)
	{
		imageWindow.ClearWindow();
		imageWindow.AddImage(camResultData->imageData.image.ReduceDomain(inspectionWindow).CropDomain());
	}
	DisplayResultRegion();
	HSystem::SetSystem("flush_graphic", "true");
	UpdateData();
	m_imagenumber.Format(L"Sheet No: %d\t\t\t Golden Name: %s", chartData->docCount, CString(chartData->goldenName.c_str()));
	UpdateData(FALSE);
	LeaveCriticalSection(&resultMutex);

	resultReceived = false;
	return 1;
}



BOOL CameraResultViewer::CreateFontObject(int nOption, CFont* pFont)
{
	if (nOption == 1) // Verical Medium Font
		pFont->CreateFont(160, 0, 900, 0, FW_BOLD, FALSE, FALSE, FALSE,
			0, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
			DEFAULT_QUALITY,
			VARIABLE_PITCH | FF_ROMAN, L"Arial");
	if (nOption == 2) // Horizontal Medium Font
		pFont->CreateFont(160, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
			0, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
			DEFAULT_QUALITY,
			VARIABLE_PITCH | FF_ROMAN, L"Roman");
	if (nOption == 3) // Horizontal Small Font
		pFont->CreateFont(140, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
			0, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
			DEFAULT_QUALITY,
			VARIABLE_PITCH | FF_ROMAN, L"Roman");
	if (nOption == 4) // Horizontal Small Font
		pFont->CreateFont(140, 0, 0, 0, FW_MEDIUM, FALSE, FALSE, FALSE,
			0, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
			DEFAULT_QUALITY,
			VARIABLE_PITCH | FF_ROMAN, L"Roman");
	return TRUE;
}



void CameraResultViewer::OnBnClickedButton1()
{
	// TODO: Add your control notification handler code here
//	chartData->GenerateReport();
}
